import React, { useState } from "react";
import { useNavigate } from "react-router-dom";
import api from "../api/client";
import BiometricsSignIn from "../components/forms/BiometricsSignIn";
import useToast from "../hooks/useToast";
import ToastContainer from "../components/ToastContainer";
import ConfirmToast from "../components/ConfirmToast";
import { generateAuthToken, storeAuthToken } from "../utils/authTokenGenerator";
import useOfflineTable from "../hooks/useOfflineTable";

const LogoutButton = () => {
  const DEBUG = false;
  const navigate = useNavigate();
  const [showBiometrics, setShowBiometrics] = useState(false);
  const [userProfile, setUserProfile] = useState(null);
  const [hasCamera, setHasCamera] = useState(true);
  const [recordSignOut, setRecordSignOut] = useState(false);
  const [autoCloseTimer, setAutoCloseTimer] = useState(null);
  const [showEndDayConfirm, setShowEndDayConfirm] = useState(false);
  const [generatedCode, setGeneratedCode] = useState(null);
  const [codeExpiresAt, setCodeExpiresAt] = useState(null);
  const [showCodeModal, setShowCodeModal] = useState(false);
  const [codePurpose, setCodePurpose] = useState('signin'); // 'signin' | 'signout'
  const { toasts, showToast, removeToast } = useToast();
  const autoGeneratedRef = React.useRef(false);
  const { addRow: addWorkerRow, updateRow: updateWorkerRow, rows: workerRows = [], isOnline: workersOnline } = useOfflineTable('worker_attendance_records');

  const handleLogout = async () => {
    try {
      // Get user profile first
      const { data: { user: authUser } } = await api.auth.getUser();
      if (authUser?.id) {
        const { data: profile } = await api
          .from('profiles')
          .select('id, school_id, worker_id, roles:role_id(name)')
          .eq('auth_uid', authUser.id)
          .maybeSingle();

        if (profile?.id) {
          // open centered confirm modal instead of toast
          setUserProfile(profile);
          setShowEndDayConfirm(true);
          // Notify any mounted biometric overlays to present sign-out flow for this profile
          try { window.dispatchEvent(new CustomEvent('app:request-signout', { detail: { operation: 'signout', profileId: profile.id, forceShowToken: false } })); } catch (e) { console.warn('Failed to dispatch app:request-signout', e); }
          return;
        }
      }

      // No profile - just logout
      await performLogout();
    } catch (err) {
      console.error("Logout error:", err);
      showToast('Logout failed. Please try again.', 'error');
    }
  };

  const handleBiometricComplete = async () => {
    // Biometric verified - record sign-out if user confirmed
    if (userProfile?.id && recordSignOut) {
      const today = new Date().toISOString().split('T')[0];
      try {
        const { data: openRows } = await api
          .from('attendance_records')
          .select('id, sign_in_time, sign_out_time')
          .eq('user_id', userProfile.id)
          .eq('date', today)
          .order('id', { ascending: false });

        // Filter for null sign_out_time in JavaScript
        const openSession = openRows?.filter(row => !row.sign_out_time)?.[0];

        if (openSession) {
          const nowIso = new Date().toISOString();
          let hours = null;
          try {
            if (openSession.sign_in_time) {
              const dur = new Date(nowIso) - new Date(openSession.sign_in_time);
              hours = Number(((dur / (1000 * 60 * 60))).toFixed(2));
            }
          } catch (e) { /* ignore */ }

          await api
            .from('attendance_records')
            .update({ sign_out_time: nowIso, method: 'biometric', hours: hours })
            .eq('id', openSession.id);
          showToast('Work day ended successfully.', 'success');
          // Ensure worker_attendance_records also reflect sign-out for worker_id if available
          try {
            // invoke onSignOut handler flow to update worker_attendance_records (uses offline hook)
            await handleOnSignOut({ profileId: userProfile.id, signInTime: openSession.sign_in_time });
          } catch (e) {
            console.warn('Worker attendance sign-out via handleOnSignOut failed', e);
          }
        } else {
          showToast('No open session found to close.', 'warning');
        }
      } catch (err) {
        console.warn('Work sign-out update failed', err);
        showToast('Sign-out recording failed, but you will be logged out.', 'warning');
      }
    } else if (userProfile?.id && !recordSignOut) {
      // User chose to keep recording: do NOT record sign-out time. Proceed to logout immediately.
      showToast('Logging out (time not recorded).', 'info');
      // performLogout will clear local state and navigate to login. We do NOT record sign-out.
      try {
        await performLogout();
        return; // exit so we don't run the rest of the flow (revocation/generation handled in performLogout)
      } catch (e) {
        console.warn('performLogout after Keep Recording failed', e);
      }
    }

    setShowBiometrics(false);
    // clear any scheduled auto-close once we finish biometric flow
    if (autoCloseTimer) {
      clearTimeout(autoCloseTimer);
      setAutoCloseTimer(null);
    }
    // Attempt to revoke any server-side auth tokens associated with this profile
    // Only revoke tokens automatically when we are NOT generating a one-time code
    // for another device to use (i.e., when recordSignOut is false).
    if (!recordSignOut) {
      try {
        // fetch auth_uid if not present
        const { data: prof, error: profErr } = await api
          .from('profiles')
          .select('auth_uid')
          .eq('id', userProfile.id)
          .maybeSingle();

        if (!profErr) {
          const authUid = prof?.auth_uid;
          // try delete by auth_uid first
          if (authUid) {
            try {
              await api.from('auth_tokens').delete().eq('auth_uid', authUid);
            } catch (e) { /* ignore */ }
          }
        }

        // Do not attempt delete by profile_id (table schema uses auth_uid). If we couldn't
        // fetch auth_uid above, skip revocation to avoid invalid-column errors.
      } catch (err) {
        console.warn('Failed to revoke auth tokens during logout flow', err);
      }
    }

    // If the user chose to record sign-out, generate a one-time logout code and show it
    // so they can use it on another device without a webcam. We do NOT revoke tokens in
    // that case because we need the generated token to remain available for the other device.
    if (userProfile?.id && recordSignOut) {
      try {
        const token = generateAuthToken();
        const { token: storedToken, expiresAt } = await storeAuthToken(userProfile.id, token, 60);
        setGeneratedCode(storedToken || token);
        setCodeExpiresAt(expiresAt);
        setShowCodeModal(true);
        showToast('One-time sign-out code generated. Share it securely with the other device.', 'info', 10000);
      } catch (err) {
        console.error('Failed to generate sign-out code', err);
        // Fall back to immediate logout to avoid leaving user stuck
        await performLogout();
      }
    } else {
      // No code needed: revoke tokens and perform logout normally
      await performLogout();
    }
  };

  // Called by BiometricsSignIn when a sign-out attendance update was performed
  const handleOnSignOut = async (info) => {
    // Expect info to contain profileId or entityId and optionally attendanceId/worker_id/signOutTime
    try {
      if (!userProfile?.id) return;
      const profileId = info?.profileId || info?.entityId || userProfile.id;
      let workerId = info?.worker_id || userProfile.worker_id || null;

      // If we don't have workerId, try to fetch from profiles table
      if (!workerId) {
        try {
          const { data: prof, error: profErr } = await api.from('profiles').select('worker_id').eq('id', profileId).maybeSingle();
          if (!profErr && prof && prof.worker_id) workerId = prof.worker_id;
        } catch (e) {
          if (DEBUG) console.warn('Failed to fetch profile worker_id', e);
        }
      }

      if (!workerId) {
        if (DEBUG) console.warn('No worker_id available for sign-out');
        return;
      }

      const nowIso = new Date().toISOString();
      const today = nowIso.split('T')[0];

      // Look for open worker attendance rows (sign_out_time is null) from the offline cache/rows
      try {
        const openRows = Array.isArray(workerRows) ? workerRows.filter(r => r && r.worker_id === workerId && r.date === today && !r.sign_out_time) : [];
        const open = openRows && openRows.length ? openRows.sort((a,b) => (b.id || 0) - (a.id || 0))[0] : null;

        if (open) {
          let hours = null;
          try {
            if (open.sign_in_time) {
              const dur = new Date(nowIso) - new Date(open.sign_in_time);
              hours = Number(((dur / (1000 * 60 * 60))).toFixed(2));
            }
          } catch (e) { /* ignore */ }

          // Use offline-aware updateRow which will queue when offline
          await updateWorkerRow(open.id, { sign_out_time: nowIso, hours });

          if (workersOnline) showToast('Sign-out recorded.', 'success');
          else showToast('Sign-out queued and will sync when online.', 'info');
          return;
        }

        // No open row found for today — create a best-effort record combining info.signInTime if available
        const signInTime = info?.signInTime || null;
        const hours = signInTime ? Number(((new Date(nowIso) - new Date(signInTime)) / (1000 * 60 * 60)).toFixed(2)) : null;

        const payload = {
          worker_id: workerId,
          school_id: userProfile.school_id,
          date: today,
          sign_in_time: signInTime,
          sign_out_time: nowIso,
          hours,
          status: 'present',
          description: 'biometric sign out',
          recorded_by: profileId,
        };

        const res = await addWorkerRow(payload);
        // res may be the inserted row (online) or a queued descriptor (offline) — provide appropriate feedback
        if (workersOnline && res && !res.__error) {
          showToast('Sign-out recorded.', 'success');
        } else if (!workersOnline && res && (res.tempId || res.mutationKey || res.__queued)) {
          showToast('Sign-out queued and will sync when online.', 'info');
        } else if (res && res.__error) {
          showToast('Failed to record sign-out, but logging out.', 'warning');
        } else {
          // fallback message
          showToast('Sign-out recorded.', 'success');
        }
      } catch (err) {
        console.warn('Failed to record worker sign-out via onSignOut handler', err);
        showToast('Failed to record sign-out, but logging out.', 'warning');
      }
    } catch (err) {
      console.warn('handleOnSignOut error', err);
    }
  };

  const handleBiometricCancel = () => {
    setShowBiometrics(false);
    showToast('Sign-out cancelled.', 'info');
  };

  const performLogout = async () => {
    try {
      const { error } = await api.auth.signOut();
      if (error) throw error;
      // clear scheduled auto-close on explicit logout
      if (autoCloseTimer) {
        clearTimeout(autoCloseTimer);
        setAutoCloseTimer(null);
      }
      localStorage.clear();
      navigate("/login");
    } catch (err) {
      console.error("Logout error:", err);
      navigate("/login");
    }
  };

  // Detect multiple active auth token rows and auto-generate a one-time code (best-effort).
  React.useEffect(() => {
    if (!showEndDayConfirm || !userProfile || autoGeneratedRef.current) return;
    autoGeneratedRef.current = true; // ensure only once per modal open

    (async () => {
      try {
  // Try to look up by auth_uid first (preferred). If profiles table doesn't have one, skip detection
        let existingTokens = null;
        let error = null;
        try {
          const { data: prof } = await api.from('profiles').select('auth_uid').eq('id', userProfile.id).maybeSingle();
          const authUid = prof?.auth_uid;
          if (authUid) {
            const res = await api.from('auth_tokens').select('id').eq('auth_uid', authUid);
            existingTokens = res.data; error = res.error;
          } else {
            // If we don't have an auth_uid for this profile, skip best-effort detection
            // rather than querying by profile_id which may not exist on the table.
            existingTokens = [];
            error = null;
          }
        } catch (e) {
          console.warn('Failed to detect existing tokens by auth_uid/profile_id', e);
        }

        if (!error && Array.isArray(existingTokens) && existingTokens.length > 1) {
          const token = generateAuthToken();
          const { token: storedToken, expiresAt } = await storeAuthToken(userProfile.id, token, 60);
          setCodePurpose('signin');
          setGeneratedCode(storedToken || token);
          setCodeExpiresAt(expiresAt);
          setShowCodeModal(true);
          showToast('Multiple active logins detected — a one-time sign-in code was generated for other devices.', 'info', 10000);
        }
      } catch (err) {
        console.warn('Auto-detect / generate code failed', err);
      }
    })();
  }, [showEndDayConfirm, userProfile]);

  return (
    <>
      <ToastContainer toasts={toasts} removeToast={removeToast} />
      {showEndDayConfirm && userProfile && (
        <div style={{ position: 'fixed', inset: 0, zIndex: 9999, display: 'flex', alignItems: 'center', justifyContent: 'center', background: 'rgba(0,0,0,0.4)' }}>
          <div style={{ background: 'white', padding: 20, borderRadius: 8, maxWidth: '90vw', width: 520 }}>
            <ConfirmToast
              message="End your work day? This will record your sign-out time."
              yesText="Yes, End Day"
              noText="No, Keep Recording"
              onYes={() => {
                (async () => {
                  setShowEndDayConfirm(false);
                  setRecordSignOut(true);
                  // check for camera availability first
                  try {
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const videoDevices = devices.filter((d) => d.kind === 'videoinput');
                    setHasCamera(Boolean(videoDevices && videoDevices.length > 0));
                  } catch (e) {
                    setHasCamera(false);
                  }
                  // show biometric modal to verify and then record sign-out
                  setShowBiometrics(true);
                  try { window.dispatchEvent(new CustomEvent('app:request-signout', { detail: { operation: 'signout', profileId: userProfile.id, forceShowToken: !hasCamera } })); } catch (e) { console.warn('Failed to dispatch app:request-signout', e); }

                  // Wait briefly for any global biometric overlay to complete sign-out and emit completion.
                  // If completion is seen, performLogout here so the app logs out immediately. Otherwise the local
                  // biometric modal that's shown above will handle logout when it completes.
                  try {
                    const timeoutMs = 10000; // 10s
                    const completed = await new Promise((resolve) => {
                      let settled = false;
                      const onComplete = (ev) => { if (!settled) { settled = true; window.removeEventListener('app:request-signout-complete', onComplete); resolve(ev?.detail || true); } };
                      window.addEventListener('app:request-signout-complete', onComplete);
                      setTimeout(() => { if (!settled) { settled = true; window.removeEventListener('app:request-signout-complete', onComplete); resolve(null); } }, timeoutMs);
                    });
                    if (completed) {
                      // An external biometric overlay completed sign-out — proceed to logout now
                      try { await performLogout(); } catch (e) { console.warn('performLogout after external signout failed', e); }
                    }
                  } catch (e) {
                    console.warn('Waiting for external signout completion failed', e);
                  }

                  showToast('Please complete biometric verification to end your day.', 'info', 5000);
                })();
              }}
              onNo={() => {
                setShowEndDayConfirm(false);
                setRecordSignOut(false);
                // Schedule automatic non-recording close at 17:15 local time
                const now = new Date();
                const auto = new Date(now);
                auto.setHours(17, 15, 0, 0);
                if (auto <= now) {
                  // if already past 17:15 today, schedule for next day
                  auto.setDate(auto.getDate() + 1);
                }
                const msUntil = auto.getTime() - now.getTime();

                showToast(`You chose to keep recording. Your session will be auto-closed at ${auto.toLocaleString()}.`, 'info', 8000);

                // best-effort timeout to auto-logout (non-recording). Note: this relies on the app staying open.
                const timerId = setTimeout(async () => {
                  try {
                    showToast('Auto-closing work day (time not recorded).', 'info', 5000);
                    // perform logout without recording sign-out time
                    await performLogout();
                  } catch (err) {
                    console.warn('Auto-close failed', err);
                    try { await performLogout(); } catch(e){}
                  }
                }, msUntil);

                // store timer id on state so it can be cleared if user logs out manually
                setAutoCloseTimer(timerId);
              }}
              // expose a generate-code action to produce a one-time sign-in code
              generateCode={async () => {
                try {
                  if (!userProfile?.id) return;
                  // optional: detect other active sessions/tokens (best-effort)
                  try {
                    // Try auth_uid lookup first
                    const { data: prof } = await api.from('profiles').select('auth_uid').eq('id', userProfile.id).maybeSingle();
                    const authUid = prof?.auth_uid;
                    if (authUid) {
                      const { data: existingTokens } = await api.from('auth_tokens').select('id').eq('auth_uid', authUid);
                    }
                    // if no auth_uid, skip detection (we'll still generate a code)
                  } catch (e) {
                    // ignore detection errors
                  }

                  const token = generateAuthToken();
                  const { token: storedToken, expiresAt } = await storeAuthToken(userProfile.id, token, 60);
                  setCodePurpose('signin');
                  setGeneratedCode(storedToken || token);
                  setCodeExpiresAt(expiresAt);
                  setShowCodeModal(true);
                  showToast('One-time sign-in code generated. Share it securely with the other device.', 'info', 8000);
                } catch (err) {
                  console.error('Failed to generate sign-in code', err);
                  showToast('Failed to generate sign-in code.', 'error');
                }
              }}
            />
          </div>
        </div>
      )}
      
      {showCodeModal && (
        <div style={{ position: 'fixed', inset: 0, zIndex: 10000, display: 'flex', alignItems: 'center', justifyContent: 'center', background: 'rgba(0,0,0,0.5)' }}>
          <div style={{ background: '#fff', padding: 20, borderRadius: 8, width: '90vw', maxWidth: 420 }}>
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                  <h3 style={{ margin: 0 }}>{codePurpose === 'signout' ? 'One-time Sign-out Code' : 'One-time Sign-in Code'}</h3>
                  <button onClick={async () => { setShowCodeModal(false); await performLogout(); }} style={{ background: 'transparent', border: 'none', fontSize: 20 }}>✖</button>
                </div>
                <p style={{ marginTop: 8 }}>
                  {codePurpose === 'signout'
                    ? `Share this 6-digit sign-out code with the device that needs to confirm the end-of-day for this user. The code expires at ${codeExpiresAt ? new Date(codeExpiresAt).toLocaleString() : 'the configured time'}.`
                    : `Share this 6-digit sign-in code with the device that needs to sign in (no webcam). The code expires at ${codeExpiresAt ? new Date(codeExpiresAt).toLocaleString() : 'the configured time'}.`}
                </p>
            <div style={{ marginTop: 12, display: 'flex', gap: 8, alignItems: 'center', justifyContent: 'space-between' }}>
              <div style={{ fontSize: 28, fontWeight: 700, letterSpacing: '0.25em' }}>{generatedCode}</div>
              <div style={{ display: 'flex', gap: 8 }}>
                <button onClick={() => { navigator.clipboard?.writeText(generatedCode); showToast('Code copied to clipboard', 'success'); }} className="btn btn-secondary">Copy</button>
                <button onClick={async () => { setShowCodeModal(false); await performLogout(); }} className="btn btn-primary">Close</button>
              </div>
            </div>
          </div>
        </div>
      )}
      
      {showBiometrics && userProfile ? (
        hasCamera ? (
          <div className="biometric-modal-overlay">
            <div className="biometric-modal">
              <div className="biometric-modal-header">
                <h2>Biometric Sign-Out Required</h2>
                <button 
                  className="close-btn" 
                  onClick={handleBiometricCancel}
                  title="Cancel sign-out"
                >
                  ×
                </button>
              </div>
              <WorkerBiometrics
                userId={userProfile.id}
                workerId={userProfile.worker_id}
                schoolId={userProfile.school_id}
                forceOperation="signout"
                onCompleted={handleBiometricComplete}
                onCancel={handleBiometricCancel}
                primaryActionLabel="Sign Out"
                onSignOut={handleOnSignOut}
              />
            </div>
          </div>
        ) : (
          // No camera: render small centered overlay with compact token-only UI
          <div style={{ position: 'fixed', inset: 0, zIndex: 9999, display: 'flex', alignItems: 'center', justifyContent: 'center', background: 'rgba(0,0,0,0.4)' }}>
            <div style={{ background: '#fff', padding: 16, borderRadius: 8, width: '90vw', maxWidth: 420 }}>
              <BiometricsSignIn
                userId={userProfile.id}
                entityType="user"
                schoolId={userProfile.school_id}
                workerId={userProfile.worker_id}
                forceOperation="signout"
                onCompleted={handleBiometricComplete}
                onCancel={handleBiometricCancel}
                primaryActionLabel="Sign Out"
                onSignOut={handleOnSignOut}
              />
            </div>
          </div>
        )
      ) : (
        <button
          onClick={handleLogout}
          className="dropdown-item danger"
        >
          Logout
        </button>
      )}
    </>
  );
};

export default LogoutButton;
