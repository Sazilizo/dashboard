import React, { useState } from "react";
import { useNavigate } from "react-router-dom";
import api from "../api/client";
import BiometricsSignIn from "../components/forms/BiometricsSignIn";
import useToast from "../hooks/useToast";
import ToastContainer from "../components/ToastContainer";
import ConfirmToast from "../components/ConfirmToast";
import { generateAuthToken, storeAuthToken } from "../utils/authTokenGenerator";

const LogoutButton = () => {
  const navigate = useNavigate();
  const [showBiometrics, setShowBiometrics] = useState(false);
  const [userProfile, setUserProfile] = useState(null);
  const [hasCamera, setHasCamera] = useState(true);
  const [recordSignOut, setRecordSignOut] = useState(false);
  const [autoCloseTimer, setAutoCloseTimer] = useState(null);
  const [showEndDayConfirm, setShowEndDayConfirm] = useState(false);
  const [generatedCode, setGeneratedCode] = useState(null);
  const [codeExpiresAt, setCodeExpiresAt] = useState(null);
  const [showCodeModal, setShowCodeModal] = useState(false);
  const [codePurpose, setCodePurpose] = useState('signin'); // 'signin' | 'signout'
  const { toasts, showToast, removeToast } = useToast();
  const autoGeneratedRef = React.useRef(false);

  const handleLogout = async () => {
    try {
      // Get user profile first
      const { data: { user: authUser } } = await api.auth.getUser();
      if (authUser?.id) {
        const { data: profile } = await api
          .from('profiles')
          .select('id, school_id, worker_id, roles:role_id(name)')
          .eq('auth_uid', authUser.id)
          .maybeSingle();

        if (profile?.id) {
          // open centered confirm modal instead of toast
          setUserProfile(profile);
          setShowEndDayConfirm(true);
          return;
        }
      }

      // No profile - just logout
      await performLogout();
    } catch (err) {
      console.error("Logout error:", err);
      showToast('Logout failed. Please try again.', 'error');
    }
  };

  const handleBiometricComplete = async () => {
    // Biometric verified - record sign-out if user confirmed
    if (userProfile?.id && recordSignOut) {
      const today = new Date().toISOString().split('T')[0];
      try {
        const { data: openRows } = await api
          .from('attendance_records')
          .select('id')
          .eq('user_id', userProfile.id)
          .eq('date', today)
          .order('id', { ascending: false });

        // Filter for null sign_out_time in JavaScript
        const openSession = openRows?.filter(row => !row.sign_out_time)?.[0];

        if (openSession) {
          await api
            .from('attendance_records')
            .update({ sign_out_time: new Date().toISOString(), method: 'biometric' })
            .eq('id', openSession.id);
          
          showToast('Work day ended successfully.', 'success');
        } else {
          showToast('No open session found to close.', 'warning');
        }
      } catch (err) {
        console.warn('Work sign-out update failed', err);
        showToast('Sign-out recording failed, but you will be logged out.', 'warning');
      }
    } else if (userProfile?.id && !recordSignOut) {
      showToast('Logging out (time not recorded).', 'info');
    }

    setShowBiometrics(false);
    // clear any scheduled auto-close once we finish biometric flow
    if (autoCloseTimer) {
      clearTimeout(autoCloseTimer);
      setAutoCloseTimer(null);
    }
    // Attempt to revoke any server-side auth tokens associated with this profile
    // Only revoke tokens automatically when we are NOT generating a one-time code
    // for another device to use (i.e., when recordSignOut is false).
    if (!recordSignOut) {
      try {
        // fetch auth_uid if not present
        const { data: prof, error: profErr } = await api
          .from('profiles')
          .select('auth_uid')
          .eq('id', userProfile.id)
          .maybeSingle();

        if (!profErr) {
          const authUid = prof?.auth_uid;
          // try delete by auth_uid first
          if (authUid) {
            try {
              await api.from('auth_tokens').delete().eq('auth_uid', authUid);
            } catch (e) { /* ignore */ }
          }
        }

        // Do not attempt delete by profile_id (table schema uses auth_uid). If we couldn't
        // fetch auth_uid above, skip revocation to avoid invalid-column errors.
      } catch (err) {
        console.warn('Failed to revoke auth tokens during logout flow', err);
      }
    }

    // If the user chose to record sign-out, generate a one-time logout code and show it
    // so they can use it on another device without a webcam. We do NOT revoke tokens in
    // that case because we need the generated token to remain available for the other device.
    if (userProfile?.id && recordSignOut) {
      try {
        const token = generateAuthToken();
        const { token: storedToken, expiresAt } = await storeAuthToken(userProfile.id, token, 60);
        setGeneratedCode(storedToken || token);
        setCodeExpiresAt(expiresAt);
        setShowCodeModal(true);
        showToast('One-time sign-out code generated. Share it securely with the other device.', 'info', 10000);
      } catch (err) {
        console.error('Failed to generate sign-out code', err);
        // Fall back to immediate logout to avoid leaving user stuck
        await performLogout();
      }
    } else {
      // No code needed: revoke tokens and perform logout normally
      await performLogout();
    }
  };

  const handleBiometricCancel = () => {
    setShowBiometrics(false);
    showToast('Sign-out cancelled.', 'info');
  };

  const performLogout = async () => {
    try {
      const { error } = await api.auth.signOut();
      if (error) throw error;
      // clear scheduled auto-close on explicit logout
      if (autoCloseTimer) {
        clearTimeout(autoCloseTimer);
        setAutoCloseTimer(null);
      }
      localStorage.clear();
      navigate("/login");
    } catch (err) {
      console.error("Logout error:", err);
      navigate("/login");
    }
  };

  // Detect multiple active auth token rows and auto-generate a one-time code (best-effort).
  React.useEffect(() => {
    if (!showEndDayConfirm || !userProfile || autoGeneratedRef.current) return;
    autoGeneratedRef.current = true; // ensure only once per modal open

    (async () => {
      try {
  // Try to look up by auth_uid first (preferred). If profiles table doesn't have one, skip detection
        let existingTokens = null;
        let error = null;
        try {
          const { data: prof } = await api.from('profiles').select('auth_uid').eq('id', userProfile.id).maybeSingle();
          const authUid = prof?.auth_uid;
          if (authUid) {
            const res = await api.from('auth_tokens').select('id').eq('auth_uid', authUid);
            existingTokens = res.data; error = res.error;
          } else {
            // If we don't have an auth_uid for this profile, skip best-effort detection
            // rather than querying by profile_id which may not exist on the table.
            existingTokens = [];
            error = null;
          }
        } catch (e) {
          console.warn('Failed to detect existing tokens by auth_uid/profile_id', e);
        }

        if (!error && Array.isArray(existingTokens) && existingTokens.length > 1) {
          const token = generateAuthToken();
          const { token: storedToken, expiresAt } = await storeAuthToken(userProfile.id, token, 60);
          setCodePurpose('signin');
          setGeneratedCode(storedToken || token);
          setCodeExpiresAt(expiresAt);
          setShowCodeModal(true);
          showToast('Multiple active logins detected — a one-time sign-in code was generated for other devices.', 'info', 10000);
        }
      } catch (err) {
        console.warn('Auto-detect / generate code failed', err);
      }
    })();
  }, [showEndDayConfirm, userProfile]);

  return (
    <>
      <ToastContainer toasts={toasts} removeToast={removeToast} />
      {showEndDayConfirm && userProfile && (
        <div style={{ position: 'fixed', inset: 0, zIndex: 9999, display: 'flex', alignItems: 'center', justifyContent: 'center', background: 'rgba(0,0,0,0.4)' }}>
          <div style={{ background: 'white', padding: 20, borderRadius: 8, maxWidth: '90vw', width: 520 }}>
            <ConfirmToast
              message="End your work day? This will record your sign-out time."
              yesText="Yes, End Day"
              noText="No, Keep Recording"
              onYes={() => {
                (async () => {
                  setShowEndDayConfirm(false);
                  setRecordSignOut(true);
                  // check for camera availability first
                  try {
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    const videoDevices = devices.filter((d) => d.kind === 'videoinput');
                    setHasCamera(Boolean(videoDevices && videoDevices.length > 0));
                  } catch (e) {
                    setHasCamera(false);
                  }
                  // show biometric modal to verify and then record sign-out
                  setShowBiometrics(true);
                  showToast('Please complete biometric verification to end your day.', 'info', 5000);
                })();
              }}
              onNo={() => {
                setShowEndDayConfirm(false);
                setRecordSignOut(false);
                // Schedule automatic non-recording close at 17:15 local time
                const now = new Date();
                const auto = new Date(now);
                auto.setHours(17, 15, 0, 0);
                if (auto <= now) {
                  // if already past 17:15 today, schedule for next day
                  auto.setDate(auto.getDate() + 1);
                }
                const msUntil = auto.getTime() - now.getTime();

                showToast(`You chose to keep recording. Your session will be auto-closed at ${auto.toLocaleString()}.`, 'info', 8000);

                // best-effort timeout to auto-logout (non-recording). Note: this relies on the app staying open.
                const timerId = setTimeout(async () => {
                  try {
                    showToast('Auto-closing work day (time not recorded).', 'info', 5000);
                    // perform logout without recording sign-out time
                    await performLogout();
                  } catch (err) {
                    console.warn('Auto-close failed', err);
                    try { await performLogout(); } catch(e){}
                  }
                }, msUntil);

                // store timer id on state so it can be cleared if user logs out manually
                setAutoCloseTimer(timerId);
              }}
              // expose a generate-code action to produce a one-time sign-in code
              generateCode={async () => {
                try {
                  if (!userProfile?.id) return;
                  // optional: detect other active sessions/tokens (best-effort)
                  try {
                    // Try auth_uid lookup first
                    const { data: prof } = await api.from('profiles').select('auth_uid').eq('id', userProfile.id).maybeSingle();
                    const authUid = prof?.auth_uid;
                    if (authUid) {
                      const { data: existingTokens } = await api.from('auth_tokens').select('id').eq('auth_uid', authUid);
                    }
                    // if no auth_uid, skip detection (we'll still generate a code)
                  } catch (e) {
                    // ignore detection errors
                  }

                  const token = generateAuthToken();
                  const { token: storedToken, expiresAt } = await storeAuthToken(userProfile.id, token, 60);
                  setCodePurpose('signin');
                  setGeneratedCode(storedToken || token);
                  setCodeExpiresAt(expiresAt);
                  setShowCodeModal(true);
                  showToast('One-time sign-in code generated. Share it securely with the other device.', 'info', 8000);
                } catch (err) {
                  console.error('Failed to generate sign-in code', err);
                  showToast('Failed to generate sign-in code.', 'error');
                }
              }}
            />
          </div>
        </div>
      )}
      
      {showCodeModal && (
        <div style={{ position: 'fixed', inset: 0, zIndex: 10000, display: 'flex', alignItems: 'center', justifyContent: 'center', background: 'rgba(0,0,0,0.5)' }}>
          <div style={{ background: '#fff', padding: 20, borderRadius: 8, width: '90vw', maxWidth: 420 }}>
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                  <h3 style={{ margin: 0 }}>{codePurpose === 'signout' ? 'One-time Sign-out Code' : 'One-time Sign-in Code'}</h3>
                  <button onClick={async () => { setShowCodeModal(false); await performLogout(); }} style={{ background: 'transparent', border: 'none', fontSize: 20 }}>✖</button>
                </div>
                <p style={{ marginTop: 8 }}>
                  {codePurpose === 'signout'
                    ? `Share this 6-digit sign-out code with the device that needs to confirm the end-of-day for this user. The code expires at ${codeExpiresAt ? new Date(codeExpiresAt).toLocaleString() : 'the configured time'}.`
                    : `Share this 6-digit sign-in code with the device that needs to sign in (no webcam). The code expires at ${codeExpiresAt ? new Date(codeExpiresAt).toLocaleString() : 'the configured time'}.`}
                </p>
            <div style={{ marginTop: 12, display: 'flex', gap: 8, alignItems: 'center', justifyContent: 'space-between' }}>
              <div style={{ fontSize: 28, fontWeight: 700, letterSpacing: '0.25em' }}>{generatedCode}</div>
              <div style={{ display: 'flex', gap: 8 }}>
                <button onClick={() => { navigator.clipboard?.writeText(generatedCode); showToast('Code copied to clipboard', 'success'); }} className="btn btn-secondary">Copy</button>
                <button onClick={async () => { setShowCodeModal(false); await performLogout(); }} className="btn btn-primary">Close</button>
              </div>
            </div>
          </div>
        </div>
      )}
      
      {showBiometrics && userProfile ? (
        hasCamera ? (
          <div className="biometric-modal-overlay">
            <div className="biometric-modal">
              <div className="biometric-modal-header">
                <h2>Biometric Sign-Out Required</h2>
                <button 
                  className="close-btn" 
                  onClick={handleBiometricCancel}
                  title="Cancel sign-out"
                >
                  ×
                </button>
              </div>
              <BiometricsSignIn
                userId={userProfile.id}
                entityType="user"
                schoolId={userProfile.school_id}
                workerId={userProfile.worker_id}
                forceOperation="signout"
                onCompleted={handleBiometricComplete}
                onCancel={handleBiometricCancel}
              />
            </div>
          </div>
        ) : (
          // No camera: render small centered overlay with compact token-only UI
          <div style={{ position: 'fixed', inset: 0, zIndex: 9999, display: 'flex', alignItems: 'center', justifyContent: 'center', background: 'rgba(0,0,0,0.4)' }}>
            <div style={{ background: '#fff', padding: 16, borderRadius: 8, width: '90vw', maxWidth: 420 }}>
              <BiometricsSignIn
                userId={userProfile.id}
                entityType="user"
                schoolId={userProfile.school_id}
                workerId={userProfile.worker_id}
                forceOperation="signout"
                onCompleted={handleBiometricComplete}
                onCancel={handleBiometricCancel}
              />
            </div>
          </div>
        )
      ) : (
        <button
          onClick={handleLogout}
          className="dropdown-item danger"
        >
          Logout
        </button>
      )}
    </>
  );
};

export default LogoutButton;
