import React, { useState } from "react";
import { useNavigate } from "react-router-dom";
import api from "../api/client";
import useToast from "../hooks/useToast";
import ToastContainer from "../components/ToastContainer";
import ConfirmToast from "../components/ConfirmToast";
import { generateAuthToken, storeAuthToken } from "../utils/authTokenGenerator";
import useOfflineTable from "../hooks/useOfflineTable";

const LogoutButton = () => {
  const DEBUG = false;
  const navigate = useNavigate();
  const [showBiometrics, setShowBiometrics] = useState(false);
  const [userProfile, setUserProfile] = useState(null);
  const [hasCamera, setHasCamera] = useState(true);
  const [recordSignOut, setRecordSignOut] = useState(false);
  const [autoCloseTimer, setAutoCloseTimer] = useState(null);
  const [showEndDayConfirm, setShowEndDayConfirm] = useState(false);
  const [generatedCode, setGeneratedCode] = useState(null);
  const [codeExpiresAt, setCodeExpiresAt] = useState(null);
  const [showCodeModal, setShowCodeModal] = useState(false);
  const [codePurpose, setCodePurpose] = useState('signin'); // 'signin' | 'signout'
  const { toasts, showToast, removeToast } = useToast();
  // WorkerBiometrics removed — use simple fallback UI instead
  const autoGeneratedRef = React.useRef(false);
  const { addRow: addWorkerRow, updateRow: updateWorkerRow, rows: workerRows = [], isOnline: workersOnline } = useOfflineTable('worker_attendance_records');

  const handleLogout = async () => {
    try {
      // Get user profile first
      const { data: { user: authUser } } = await api.auth.getUser();
      if (authUser?.id) {
        const { data: profile } = await api
          .from('profiles')
          .select('id, school_id, worker_id, roles:role_id(name)')
          .eq('auth_uid', authUser.id)
          .maybeSingle();

        if (profile?.id) {
          // open centered confirm modal instead of toast
          setUserProfile(profile);
          setShowEndDayConfirm(true);
          // Notify any mounted biometric overlays to present sign-out flow for this profile
          try { window.dispatchEvent(new CustomEvent('app:request-signout', { detail: { operation: 'signout', profileId: profile.id, forceShowToken: false } })); } catch (e) { console.warn('Failed to dispatch app:request-signout', e); }
          return;
        }
      }

      // No profile - just logout
      await performLogout();
    } catch (err) {
      console.error("Logout error:", err);
      showToast('Logout failed. Please try again.', 'error');
    }
  };

  const handleBiometricComplete = async () => {
    // Biometric verified - record sign-out if user confirmed
    if (userProfile?.id && recordSignOut) {
      const today = new Date().toISOString().split('T')[0];
      try {
        const { data: openRows } = await api
          .from('attendance_records')
          .select('id, sign_in_time, sign_out_time')
          .eq('user_id', userProfile.id)
          .eq('date', today)
          .order('id', { ascending: false });

        const openSession = Array.isArray(openRows) ? openRows.find(r => !r.sign_out_time) : null;

        if (openSession) {
          const nowIso = new Date().toISOString();
          let hours = null;
          try {
            if (openSession.sign_in_time) {
              const dur = new Date(nowIso) - new Date(openSession.sign_in_time);
              hours = Number(((dur / (1000 * 60 * 60))).toFixed(2));
            }
          } catch (e) { /* ignore */ }

          await api
            .from('attendance_records')
            .update({ sign_out_time: nowIso, method: 'biometric', hours: hours })
            .eq('id', openSession.id);
          showToast('Work day ended successfully.', 'success');
          try {
            await handleOnSignOut({ profileId: userProfile.id, signInTime: openSession.sign_in_time });
          } catch (e) {
            console.warn('Worker attendance sign-out via handleOnSignOut failed', e);
          }
        } else {
          // No existing session: create a sign-out record (best-effort)
          const nowIso = new Date().toISOString();
          const roleName = (userProfile?.roles?.name || "").toLowerCase?.() || "";
          const payload = {
            user_id: userProfile.id,
            school_id: userProfile.school_id,
            date: today,
            status: 'present',
            method: 'biometric',
            note: 'biometric sign-out',
            sign_out_time: nowIso,
          };
          if (roleName.includes('tutor') && userProfile.worker_id) payload.tutor_id = userProfile.worker_id;
          if (roleName.includes('coach') && userProfile.worker_id) payload.coach_id = userProfile.worker_id;

          try {
            await api.from('attendance_records').insert(payload);
            showToast('Sign-out recorded.', 'success');
          } catch (insErr) {
            console.warn('Sign-out insert failed', insErr?.message || insErr);
            showToast('Sign-out recorded (best-effort).', 'warning');
          }
        }
      } catch (err) {
        console.error('Error checking existing attendance rows:', err);
        try {
          const nowIso = new Date().toISOString();
          const roleName = (userProfile?.roles?.name || "").toLowerCase?.() || "";
          const payload = {
            user_id: userProfile.id,
            school_id: userProfile.school_id,
            date: today,
            status: 'present',
            method: 'biometric',
            note: 'biometric sign-out',
            sign_out_time: nowIso,
          };
          if (roleName.includes('tutor') && userProfile.worker_id) payload.tutor_id = userProfile.worker_id;
          if (roleName.includes('coach') && userProfile.worker_id) payload.coach_id = userProfile.worker_id;
          await api.from('attendance_records').insert(payload);
          showToast('Sign-out recorded (fallback).', 'success');
        } catch (insErr) {
          console.warn('Sign-out insert failed (fallback)', insErr?.message || insErr);
          showToast('Failed to record sign-out, but logging out.', 'warning');
        }
      }
    }

    // Attempt to revoke any short-lived auth tokens associated with this profile (best-effort)
    try {
      const { data: prof, error: profErr } = await api.from('profiles').select('auth_uid').eq('id', userProfile.id).maybeSingle();
      if (!profErr) {
        const authUid = prof?.auth_uid;
        if (authUid) {
          try {
            await api.from('auth_tokens').delete().eq('auth_uid', authUid);
          } catch (e) { /* ignore */ }
        }
      }
    } catch (err) {
      console.warn('Failed to revoke auth tokens during logout flow', err);
    }

    // If the user chose to record sign-out, generate a one-time logout code and show it
    // so they can use it on another device without a webcam. We do NOT revoke tokens in
    // that case because we need the generated token to remain available for the other device.
    if (userProfile?.id && recordSignOut) {
      try {
        const token = generateAuthToken();
        const { token: storedToken, expiresAt } = await storeAuthToken(userProfile.id, token, 60);
        setGeneratedCode(storedToken || token);
        setCodeExpiresAt(expiresAt);
        setShowCodeModal(true);
        showToast('One-time sign-out code generated. Share it securely with the other device.', 'info', 10000);
      } catch (err) {
        console.error('Failed to generate sign-out code', err);
        // Fall back to immediate logout to avoid leaving user stuck
        await performLogout();
      }
    } else {
      // No code needed: revoke tokens and perform logout normally
      await performLogout();
    }
  };

  // Called by biometric overlay when a sign-out attendance update was performed
  const handleOnSignOut = async (info) => {
    // Expect info to contain profileId or entityId and optionally attendanceId/worker_id/signOutTime
    try {
      if (!userProfile?.id) return;
      const profileId = info?.profileId || info?.entityId || userProfile.id;
      let workerId = info?.worker_id || userProfile.worker_id || null;

      // If we don't have workerId, try to fetch from profiles table
      if (!workerId) {
        try {
          const { data: prof, error: profErr } = await api.from('profiles').select('worker_id').eq('id', profileId).maybeSingle();
          if (!profErr && prof && prof.worker_id) workerId = prof.worker_id;
        } catch (e) {
          if (DEBUG) console.warn('Failed to fetch profile worker_id', e);
        }
      }

      if (!workerId) {
        if (DEBUG) console.warn('No worker_id available for sign-out');
        return;
      }

      const nowIso = new Date().toISOString();
      const today = nowIso.split('T')[0];

      // Look for open worker attendance rows (sign_out_time is null) from the offline cache/rows
      try {
        const openRows = Array.isArray(workerRows) ? workerRows.filter(r => r && r.worker_id === workerId && r.date === today && !r.sign_out_time) : [];
        const open = openRows && openRows.length ? openRows.sort((a,b) => (b.id || 0) - (a.id || 0))[0] : null;

        if (open) {
          let hours = null;
          try {
            if (open.sign_in_time) {
              const dur = new Date(nowIso) - new Date(open.sign_in_time);
              hours = Number(((dur / (1000 * 60 * 60))).toFixed(2));
            }
          } catch (e) { /* ignore */ }

          // Use offline-aware updateRow which will queue when offline
          await updateWorkerRow(open.id, { sign_out_time: nowIso, hours });

          if (workersOnline) showToast('Sign-out recorded.', 'success');
          else showToast('Sign-out queued and will sync when online.', 'info');
          return;
        }

        // No open row found for today — create a best-effort record combining info.signInTime if available
        const signInTime = info?.signInTime || null;
        const hours = signInTime ? Number(((new Date(nowIso) - new Date(signInTime)) / (1000 * 60 * 60)).toFixed(2)) : null;

        const payload = {
          worker_id: workerId,
          school_id: userProfile.school_id,
          date: today,
          sign_in_time: signInTime,
          sign_out_time: nowIso,
          hours,
          status: 'present',
          description: 'biometric sign out',
          recorded_by: profileId,
        };

        const res = await addWorkerRow(payload);
        // res may be the inserted row (online) or a queued descriptor (offline) — provide appropriate feedback
        if (workersOnline && res && !res.__error) {
          showToast('Sign-out recorded.', 'success');
        } else if (!workersOnline && res && (res.tempId || res.mutationKey || res.__queued)) {
          showToast('Sign-out queued and will sync when online.', 'info');
        } else if (res && res.__error) {
          showToast('Failed to record sign-out, but logging out.', 'warning');
        } else {
          // fallback message
          showToast('Sign-out recorded.', 'success');
        }
      } catch (err) {
        console.warn('Failed to record worker sign-out via onSignOut handler', err);
        showToast('Failed to record sign-out, but logging out.', 'warning');
      }
    } catch (err) {
      console.warn('handleOnSignOut error', err);
    }
  };

  const handleBiometricCancel = () => {
    setShowBiometrics(false);
    showToast('Sign-out cancelled.', 'info');
  };

  const performLogout = async () => {
    try {
      const { error } = await api.auth.signOut();
      if (error) throw error;
      // clear scheduled auto-close on explicit logout
      if (autoCloseTimer) {
        clearTimeout(autoCloseTimer);
        setAutoCloseTimer(null);
      }
      localStorage.clear();
      navigate("/login");
    } catch (err) {
      console.error("Logout error:", err);
      navigate("/login");
    }
  };

  // Detect multiple active auth token rows and auto-generate a one-time code (best-effort).
  React.useEffect(() => {
    if (!showEndDayConfirm || !userProfile || autoGeneratedRef.current) return;
    autoGeneratedRef.current = true; // ensure only once per modal open

    (async () => {
      try {
  // Try to look up by auth_uid first (preferred). If profiles table doesn't have one, skip detection
        let existingTokens = null;
        let error = null;
        try {
          const { data: prof } = await api.from('profiles').select('auth_uid').eq('id', userProfile.id).maybeSingle();
          const authUid = prof?.auth_uid;
          if (authUid) {
            const res = await api.from('auth_tokens').select('id').eq('auth_uid', authUid);
            existingTokens = res.data; error = res.error;
          } else {
            // If we don't have an auth_uid for this profile, skip best-effort detection
            // rather than querying by profile_id which may not exist on the table.
            existingTokens = [];
            error = null;
          }
        } catch (e) {
          console.warn('Failed to detect existing tokens by auth_uid/profile_id', e);
        }

        if (!error && Array.isArray(existingTokens) && existingTokens.length > 1) {
          const token = generateAuthToken();
          const { token: storedToken, expiresAt } = await storeAuthToken(userProfile.id, token, 60);
          setCodePurpose('signin');
          setGeneratedCode(storedToken || token);
          setCodeExpiresAt(expiresAt);
          setShowCodeModal(true);
          showToast('Multiple active logins detected — a one-time sign-in code was generated for other devices.', 'info', 10000);
        }
      } catch (err) {
        console.warn('Auto-detect / generate code failed', err);
      }
    })();
  }, [showEndDayConfirm, userProfile]);

  return (
    <>
      <ToastContainer toasts={toasts} removeToast={removeToast} />

      <div style={{ display: 'inline-block' }}>
        <button
          onClick={async () => {
            const ok = window.confirm('End your work day and log out?');
            if (!ok) return;
            try {
              await performLogout();
            } catch (err) {
              console.warn('Logout failed', err);
              showToast('Logout failed. Please try again.', 'error');
            }
          }}
          className="dropdown-item danger"
        >
          Logout
        </button>
      </div>
    </>
  );
};

export default LogoutButton;
